

$mkdir filetorename
$cd filetorename
$touch file{1..5}.txt
$ls

Si lo que quieres es renombrar un solo archivo llamado file1.txt, se tendría que ver así:

$rename 's/file1/newfile1/' file.txt

-----------------------------------------------
modificar la extensión de los archivos a .php, puedes hacerlo de la siguiente manera:

$rename 's/.txt/.php' *.txt
$ls


-----------------------------------------------
Eliminar del nombre del fichero caracteres especiales que no están entre la letra a y la z (a-z) . Dejando en el nombre del fichero solo caracteres alfanuméricos.
Ejemplo:
mi-fichero.txt por mifichero.txt

$rename -v -n 'v/[^a-z]//' *.*

-----------------------------------------------
Modifica nombres de archivo a mayúsculas:

$rename 'y/a-z/A-Z' *

-----------------------------------------------
Modifica nombres de archivo a minúsculas:

$rename 'A-Z/a-z' *

-----------------------------------------------
Reemplazar espacios con guiones bajos en los nombres de archivos:

$rename 'y/ /_/' *

rename -v 'y/(/_/' *                                  renombrar "(" por "_" -----  '/cambia esto/ por esto /'
rename 's/ _720p_24fps_H264-192kbit_AAC//g' *.mp4     renombrar '/_720p_24fps_H264-192kbit_AAC/por esto/'

-----------------------------------------------
Simula la operacion y muestra como quedaria sin realizar los cambios

$rename -n 's/new/test' new.txt
salida:
$rename(new.txt, test.txt)

-----------------------------------------------
forzar rename -f

$rename 's/new/test/' new.txt
salida:
$new.txt not renamed: test.txt already exists
$rename -f 's/new/test/' new.txt
salida: La operación se completó sin problemas y test.txt se sobrescribió.


-----------------------------------------------
Renombrar un grupo de imágenes con nombres diferentes. Si tenemos un grupo de imágenes (por ejemplo PNG) a las que les queremos añadir una información en la parte final del nombre de la imagen antes de la extensión.
Ejemplo:
nombreimagen.png por nombreimagen_150x150.png

$rename -v -n 's/\.png/\_150x150.png/' *.png

Vamos a suponer que queremos reemplazar los guiones bajos por guiones medios ("_" por "-") en los nombres de nuestros archivos de un directorio determinado.

$rename -v -n 's/_/-/' *.jpg


-----------------------------------------------
Añadir texto al inicio del nombre del fichero. Con el carácter ^ le indicamos al comando rename que se sitúe en el comienzo del nombre del fichero y ahí inserte o ejecute la segunda parte.
Ejemplo:
leccion 1.doc,
leccion 2.doc ...
por
tema - leccion 1.doc,
tema - leccion 2.doc ..

$rename -v -n 's/^/tema – /' *.doc


-----------------------------------------------
Si queremos eliminar varios caracteres antes de un punto de corte determinado.
Ejemplo:
texto1_abc_001_small.jpg,
texto2_abc_002_small.jpg,
texto3_abc_003_small.jpgpor
texto1_small.jpg,
texto2_small.jpg,
texto3_small.jpg
Utilizamos para el corte la cadena "_small" y le decimos que nos elimine los 8 caracteres (\w) anteriores, o los reemplace por lo que indiquemos en la segunda parte del comando rename.

$rename -v -n 's/\w{8}\_small/_small/' *.jpg


-----------------------------------------------
reemplazar desde un punto determinado de corte, pero respetando un número concreto de caracteres numéricos antes de la parte donde se produce el corte. Para este caso usamos el elemento "$1" en la cadena de la parte derecha, para que nos coja esa variable obtenida de la parte izquierda.  Viendo el ejemplo se entenderá mejor.
Ejemplo:
texto1_uno001_small.jpg,
texto2_otro002_small.jpg,
texto3_cualquiera003_small.jpg ...por
texto1_uno_ADD-001_small.jpg,
texto2_otro_ADD-002_small.jpg,
texto3_cualquiera_ADD-003_small.jpg ...

Utilizamos para el corte la cadena "_small" y le decimos que nos guarde los 3 caracteres numéricos (\d) anteriores (001, 002, 003...) utilizando el $1 en la segunda parte del comando (la expresión de la derecha) Nos añadirá o modificara lo indicado en la segunda parte del comando rename justo antes de esos 3 caracteres reservados antes del corte.

$rename -v -n 's/(\w{3})\_small/_ADD–$1_small/' *.jpg

-----------------------------------------------

A continuación dejo un listado explicando (en inglés) las expresiones regulares que se pueden utilizar con este comando rename:

^	matches the beginning of the line -------(coincide con el comienzo de la línea)

$	matches the end of the line -------(coincide con el final de la línea)

.	Matches any single character -------(Coincide con cualquier carácter)

(character)*	match arbitrarily many occurences of (character) -------(coincide arbitrariamente con muchas apariciones de (carácter))

(character)?	Match 0 or 1 instance of (character) -------(Coincide con 0 o 1 instancia de (caracter))

[abcdef]	Match any character enclosed in [] (in this instance, a b c d e or f) ranges of characters such as [a-z] are permitted. The behaviour of this deserves more description. --------(Coincide con cualquier carácter encerrado en [] (en este caso, a b c d e of) se permiten rangos de caracteres como [a-z]. El comportamiento de esto merece más descripción.)

[^abcdef]	Match any character NOT enclosed in [] (in this instance, any character other than a b c d e or f) -------(Coincide con cualquier carácter NO incluido en [] (en este caso, cualquier carácter que no sea a b c d e o f))

(character){m,n}	Match m-n repetitions of (character) -------( Coincide con m-n repeticiones de (carácter))

(character){m,}	Match m or more repetitions of (character) --------(Coincide con m o más repeticiones de (carácter))

(character){,n}	Match n or less (possibly 0) repetitions of (character) -------(Coincide con n o menos (posiblemente 0) repeticiones de (carácter))

(character){n}	Match exactly n repetitions of (character) -------(Coincide exactamente con n repeticiones de (carácter))


(expression)	Group operator.
 	Backreference – matches nth group
expression1|expression2	Matches expression1 or expression 2. Works with GNU sed, but this feature might not work with other forms of sed.
\w	matches any single character classified as a “word” character (alphanumeric or “_”) --------(coincide con cualquier carácter clasificado como carácter de “palabra” (alfanumérico o “_”))

\W	matches any non-“word” character -------(coincide con cualquier carácter que no sea "palabra")

\s	matches any whitespace character (space, tab, newline) -------(coincide con cualquier carácter de espacio en blanco (espacio, tabulación, nueva línea))

\S	matches any non-whitespace character -------(coincide con cualquier carácter que no sea un espacio en blanco)

\d	matches any digit character, equiv. to [0-9] --------(coincide con cualquier carácter de dígito, equivalente. a [0-9])

\D	matches any non-digit character -------(coincide con cualquier carácter que no sea un dígito)





